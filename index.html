<!DOCTYPE html>

<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Number Puzzle Solver</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

```
    body {
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        min-height: 100vh;
        padding: 20px;
    }
    
    .container {
        max-width: 1200px;
        margin: 0 auto;
        background: white;
        border-radius: 16px;
        box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        overflow: hidden;
    }
    
    .header {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        padding: 30px;
        text-align: center;
    }
    
    .header h1 {
        font-size: 28px;
        margin-bottom: 10px;
    }
    
    .content {
        padding: 30px;
    }
    
    .grid-size-selector {
        text-align: center;
        margin-bottom: 30px;
    }
    
    .grid-size-btn {
        padding: 20px 40px;
        fontSize: 24px;
        fontWeight: bold;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        border: none;
        borderRadius: 12px;
        cursor: pointer;
        transition: transform 0.2s;
        box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
    }
    
    .grid-size-btn:active {
        transform: scale(0.95);
    }
    
    .upload-section {
        text-align: center;
        margin: 30px 0;
    }
    
    .upload-btn {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        border: none;
        padding: 20px 50px;
        border-radius: 12px;
        font-size: 18px;
        font-weight: 600;
        cursor: pointer;
        transition: transform 0.2s;
        box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
    }
    
    .upload-btn:hover {
        transform: translateY(-2px);
    }
    
    .btn {
        padding: 12px 30px;
        border: none;
        border-radius: 8px;
        font-size: 16px;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.2s;
    }
    
    .btn-primary {
        background: #667eea;
        color: white;
    }
    
    .btn-secondary {
        background: #e0e0e0;
        color: #333;
    }
    
    input[type="file"] {
        display: none;
    }
    
    .status {
        text-align: center;
        margin: 20px 0;
        padding: 15px;
        background: #f5f5f5;
        border-radius: 8px;
        font-size: 16px;
    }
    
    .grid-container {
        display: inline-block;
        background: #f5f5f5;
        padding: 20px;
        border-radius: 8px;
        box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    }
    
    .grid {
        display: grid;
        gap: 4px;
        margin: 0 auto;
    }
    
    .cell {
        width: 40px;
        height: 40px;
        display: flex;
        align-items: center;
        justify-content: center;
        background: white;
        border: 2px solid #ddd;
        border-radius: 6px;
        font-weight: 600;
        font-size: 16px;
        transition: all 0.3s;
    }
    
    .cell.highlighted {
        background: #ffd700;
        border-color: #ff6b6b;
        transform: scale(1.1);
        z-index: 10;
        box-shadow: 0 4px 12px rgba(255, 107, 107, 0.4);
    }
    
    .cell.removed {
        background: #e0e0e0;
        color: #999;
        border-color: #ccc;
    }
    
    .controls {
        display: flex;
        justify-content: center;
        gap: 15px;
        margin: 30px 0;
        flex-wrap: wrap;
    }
    
    .step-info {
        text-align: center;
        margin: 20px 0;
        font-size: 18px;
        color: #333;
    }
    
    .manual-input {
        margin: 30px 0;
        text-align: center;
    }
    
    .manual-input textarea {
        width: 100%;
        max-width: 600px;
        min-height: 250px;
        padding: 20px;
        border: 2px solid #667eea;
        border-radius: 8px;
        font-family: monospace;
        font-size: 16px;
        line-height: 1.8;
    }
    
    @media (max-width: 768px) {
        .cell {
            width: 30px;
            height: 30px;
            font-size: 14px;
        }
        
        .grid {
            gap: 2px;
        }
    }
</style>
```

</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üéØ Number Puzzle Solver</h1>
            <p>Upload screenshot or type manually - finds all groups that sum to 10!</p>
        </div>

```
    <div class="content">
        <div class="grid-size-selector">
            <p style="margin-bottom: 10px; font-weight: 600; color: #333;">Grid Size:</p>
            <button id="gridSizeBtn" class="grid-size-btn">15√ó9</button>
            <p style="margin-top: 8px; font-size: 12px; color: #999;">Click to cycle</p>
        </div>
        
        <div class="upload-section" id="uploadSection">
            <input type="file" id="fileInput" accept="image/*,.heic" capture="environment" style="display: none;">
            <button class="upload-btn" id="uploadBtn">
                üì∏ Upload Photo (Auto-Solve!)
            </button>
            <br>
            <button class="btn btn-secondary" id="manualInputBtn" style="margin-top: 15px;">
                ‚å®Ô∏è Manual Input (Backup)
            </button>
        </div>
        
        <div class="manual-input" id="manualInputSection" style="display: none;">
            <p style="margin-bottom: 15px; color: #333; font-size: 16px; font-weight: 600;">
                ‚ö° Type numbers row by row:
            </p>
            <p style="margin-bottom: 15px; color: #666; font-size: 14px;" id="inputInstructions">
                Enter 15 rows of 9 numbers each. Separate numbers with spaces, press Enter for next row.
            </p>
            <textarea id="gridInput" placeholder="Example:
```

6 4 4 2 7 8 1 6 1
2 5 8 7 8 8 5 7 6
‚Ä¶‚Äù></textarea>
<div style="margin-top: 20px;">
<button class="btn btn-primary" id="solveBtn" style="font-size: 18px; padding: 15px 40px;">
üéØ Solve Puzzle!
</button>
<button class="btn btn-secondary" id="cancelBtn" style="margin-left: 10px;">
Cancel
</button>
</div>
</div>

```
        <div id="status" class="status" style="display: none;"></div>
        
        <div id="gridDisplay" style="text-align: center; display: none;">
            <div class="step-info" id="stepInfo"></div>
            <div id="gridContainer"></div>
            <div class="controls">
                <button class="btn btn-secondary" id="resetBtn">‚èÆ Reset</button>
                <button class="btn btn-secondary" id="prevBtn">‚Üê Back</button>
                <button class="btn btn-primary" id="nextBtn">Next ‚Üí</button>
            </div>
            <button class="btn btn-secondary" id="newPuzzleBtn" style="margin-top: 20px;">
                üîÑ Solve New Puzzle
            </button>
        </div>
    </div>
</div>

<script>
    const gridSizes = [
        { rows: 14, cols: 8, label: '14√ó8' },
        { rows: 15, cols: 9, label: '15√ó9' },
        { rows: 16, cols: 10, label: '16√ó10' }
    ];
    
    let currentSizeIndex = 1;
    let originalGrid = null;
    let solution = [];
    let currentStep = 0;
    
    const gridSizeBtn = document.getElementById('gridSizeBtn');
    const manualInputBtn = document.getElementById('manualInputBtn');
    const manualInputSection = document.getElementById('manualInputSection');
    const uploadSection = document.getElementById('uploadSection');
    const gridInput = document.getElementById('gridInput');
    const solveBtn = document.getElementById('solveBtn');
    const cancelBtn = document.getElementById('cancelBtn');
    const status = document.getElementById('status');
    const gridDisplay = document.getElementById('gridDisplay');
    const gridContainer = document.getElementById('gridContainer');
    const stepInfo = document.getElementById('stepInfo');
    const resetBtn = document.getElementById('resetBtn');
    const prevBtn = document.getElementById('prevBtn');
    const nextBtn = document.getElementById('nextBtn');
    const newPuzzleBtn = document.getElementById('newPuzzleBtn');
    const inputInstructions = document.getElementById('inputInstructions');
    
    const uploadBtn = document.getElementById('uploadBtn');
    const fileInput = document.getElementById('fileInput');
    
    // Upload button triggers file input
    uploadBtn.addEventListener('click', () => {
        fileInput.click();
    });
    
    // Handle file upload
    fileInput.addEventListener('change', async (e) => {
        const file = e.target.files[0];
        if (!file) return;
        
        uploadSection.style.display = 'none';
        status.style.display = 'block';
        status.textContent = 'üì∏ Processing image with OCR...';
        
        try {
            await processImageWithOCR(file);
        } catch (err) {
            status.textContent = '‚ùå OCR failed: ' + err.message;
            setTimeout(() => {
                uploadSection.style.display = 'block';
                status.style.display = 'none';
                manualInputSection.style.display = 'block';
            }, 2000);
        }
    });
    
    async function processImageWithOCR(file) {
        status.textContent = 'üì∏ Preparing image...';
        
        try {
            // Convert to base64
            const base64Image = await new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => resolve(reader.result);
                reader.onerror = reject;
                reader.readAsDataURL(file);
            });
            
            status.textContent = 'üîç Reading numbers with OCR...';
            
            // Use OCR.space API - free tier, works from GitHub Pages
            const formData = new FormData();
            formData.append('base64Image', base64Image);
            formData.append('apikey', 'helloworld');
            formData.append('language', 'eng');
            formData.append('isOverlayRequired', 'false');
            formData.append('OCREngine', '2');
            formData.append('detectOrientation', 'true');
            formData.append('scale', 'true');
            
            const response = await fetch('https://api.ocr.space/parse/image', {
                method: 'POST',
                body: formData
            });
            
            const result = await response.json();
            
            if (result.IsErroredOnProcessing) {
                throw new Error(result.ErrorMessage || 'OCR processing failed');
            }
            
            if (result.ParsedResults && result.ParsedResults.length > 0) {
                const text = result.ParsedResults[0].ParsedText;
                console.log('OCR Result:', text);
                
                // Parse the text to extract grid
                const size = gridSizes[currentSizeIndex];
                const grid = parseOCRText(text, size.rows, size.cols);
                
                if (grid) {
                    status.textContent = '‚úÖ Grid detected! Solving puzzle...';
                    originalGrid = grid;
                    solution = solvePuzzle(grid);
                    currentStep = 0;
                    
                    setTimeout(() => {
                        status.style.display = 'none';
                        gridDisplay.style.display = 'block';
                        renderGrid();
                    }, 500);
                } else {
                    throw new Error('Could not parse grid. Please ensure the image is clear and try manual input.');
                }
            } else {
                throw new Error('No text detected in image');
            }
        } catch (err) {
            console.error('OCR Error:', err);
            throw new Error(err.message || 'OCR processing failed');
        }
    }
                throw new Error('Could not parse grid from image. Please try manual input - it\'s faster anyway!');
            }
        } catch (err) {
            console.error('OCR Error:', err);
            throw new Error('OCR processing failed. Please use manual input.');
        }
    }
    
    function parseOCRText(text, expectedRows, expectedCols) {
        // Extract all digits from the text
        const allDigits = text.match(/\d/g);
        
        if (!allDigits || allDigits.length < expectedRows * expectedCols) {
            return null;
        }
        
        // Build grid from digits
        const grid = [];
        let index = 0;
        
        for (let r = 0; r < expectedRows; r++) {
            const row = [];
            for (let c = 0; c < expectedCols; c++) {
                if (index < allDigits.length) {
                    row.push(parseInt(allDigits[index]));
                    index++;
                }
            }
            if (row.length === expectedCols) {
                grid.push(row);
            }
        }
        
        // Validate grid
        if (grid.length === expectedRows && grid.every(row => row.length === expectedCols)) {
            return grid;
        }
        
        return null;
    }
    
    // Grid size cycling
    gridSizeBtn.addEventListener('click', () => {
        currentSizeIndex = (currentSizeIndex + 1) % 3;
        const size = gridSizes[currentSizeIndex];
        gridSizeBtn.textContent = size.label;
        inputInstructions.textContent = `Enter ${size.rows} rows of ${size.cols} numbers each. Separate numbers with spaces, press Enter for next row.`;
    });
    
    // Show manual input
    manualInputBtn.addEventListener('click', () => {
        manualInputSection.style.display = 'block';
        uploadSection.style.display = 'none';
        gridInput.focus();
    });
    
    // Cancel manual input
    cancelBtn.addEventListener('click', () => {
        manualInputSection.style.display = 'none';
        uploadSection.style.display = 'block';
        gridInput.value = '';
    });
    
    // Solve puzzle
    solveBtn.addEventListener('click', () => {
        const text = gridInput.value.trim();
        if (!text) {
            alert('Please enter the grid numbers');
            return;
        }
        
        try {
            const lines = text.split('\n').filter(line => line.trim());
            const grid = lines.map(line => 
                line.trim().split(/\s+/).map(n => parseInt(n))
            );
            
            const size = gridSizes[currentSizeIndex];
            
            // Validate
            if (grid.length !== size.rows) {
                alert(`Expected ${size.rows} rows, but got ${grid.length}`);
                return;
            }
            
            if (!grid.every(row => row.length === size.cols)) {
                alert(`All rows should have ${size.cols} numbers`);
                return;
            }
            
            if (grid.some(row => row.some(n => isNaN(n) || n < 0 || n > 9))) {
                alert('All numbers should be between 0 and 9');
                return;
            }
            
            // Process the grid
            originalGrid = grid;
            solution = solvePuzzle(grid);
            currentStep = 0;
            
            manualInputSection.style.display = 'none';
            gridDisplay.style.display = 'block';
            renderGrid();
            
        } catch (err) {
            alert('Error parsing grid: ' + err.message);
        }
    });
    
    // Solve puzzle algorithm
    function solvePuzzle(initialGrid) {
        const steps = [];
        let currentGrid = initialGrid.map(row => [...row]);
        let iterations = 0;
        const maxIterations = 1000;
        
        while (iterations < maxIterations) {
            const move = findBestMove(currentGrid);
            
            if (!move) break;
            
            steps.push({
                cells: move.cells,
                sum: move.sum
            });
            
            // Remove cells
            for (let cell of move.cells) {
                currentGrid[cell.row][cell.col] = null;
            }
            
            iterations++;
        }
        
        return steps;
    }
    
    function findBestMove(grid) {
        const rows = grid.length;
        const cols = grid[0].length;
        const allMoves = [];
        
        // Horizontal groups
        for (let r = 0; r < rows; r++) {
            for (let c = 0; c < cols; c++) {
                if (grid[r][c] === null) continue;
                
                for (let len = 2; len <= cols - c; len++) {
                    const cells = [];
                    let sum = 0;
                    let valid = true;
                    
                    for (let i = 0; i < len; i++) {
                        if (grid[r][c + i] === null) {
                            valid = false;
                            break;
                        }
                        cells.push({ row: r, col: c + i });
                        sum += grid[r][c + i];
                    }
                    
                    if (valid && sum === 10) {
                        allMoves.push({ cells, sum });
                    }
                }
            }
        }
        
        // Vertical groups
        for (let c = 0; c < cols; c++) {
            for (let r = 0; r < rows; r++) {
                if (grid[r][c] === null) continue;
                
                for (let len = 2; len <= rows - r; len++) {
                    const cells = [];
                    let sum = 0;
                    let valid = true;
                    
                    for (let i = 0; i < len; i++) {
                        if (grid[r + i][c] === null) {
                            valid = false;
                            break;
                        }
                        cells.push({ row: r + i, col: c });
                        sum += grid[r + i][c];
                    }
                    
                    if (valid && sum === 10) {
                        allMoves.push({ cells, sum });
                    }
                }
            }
        }
        
        // Rectangular groups
        for (let r = 0; r < rows; r++) {
            for (let c = 0; c < cols; c++) {
                if (grid[r][c] === null) continue;
                
                for (let h = 2; h <= Math.min(3, rows - r); h++) {
                    for (let w = 2; w <= Math.min(3, cols - c); w++) {
                        const cells = [];
                        let sum = 0;
                        let valid = true;
                        
                        for (let dr = 0; dr < h; dr++) {
                            for (let dc = 0; dc < w; dc++) {
                                if (grid[r + dr][c + dc] === null) {
                                    valid = false;
                                    break;
                                }
                                cells.push({ row: r + dr, col: c + dc });
                                sum += grid[r + dr][c + dc];
                            }
                            if (!valid) break;
                        }
                        
                        if (valid && sum === 10) {
                            allMoves.push({ cells, sum });
                        }
                    }
                }
            }
        }
        
        if (allMoves.length === 0) return null;
        
        allMoves.sort((a, b) => b.cells.length - a.cells.length);
        return allMoves[0];
    }
    
    function getCurrentGrid() {
        if (currentStep === 0) return originalGrid;
        
        let grid = originalGrid.map(row => [...row]);
        
        for (let i = 0; i < currentStep; i++) {
            const move = solution[i];
            for (let cell of move.cells) {
                grid[cell.row][cell.col] = null;
            }
        }
        
        return grid;
    }
    
    function renderGrid() {
        const displayGrid = getCurrentGrid();
        const highlighted = currentStep < solution.length ? solution[currentStep].cells : [];
        
        const rows = displayGrid.length;
        const cols = displayGrid[0].length;
        const cellSize = window.innerWidth < 768 ? 30 : 40;
        
        gridContainer.innerHTML = `
            <div class="grid-container">
                <div class="grid" style="grid-template-columns: repeat(${cols}, ${cellSize}px);">
                    ${displayGrid.map((row, r) => 
                        row.map((cell, c) => {
                            const isHighlighted = highlighted.some(h => h.row === r && h.col === c);
                            const isRemoved = cell === null;
                            const classes = `cell ${isHighlighted ? 'highlighted' : ''} ${isRemoved ? 'removed' : ''}`;
                            return `<div class="${classes}" style="width: ${cellSize}px; height: ${cellSize}px; font-size: ${cellSize === 30 ? 14 : 16}px;">${cell !== null ? cell : ''}</div>`;
                        }).join('')
                    ).join('')}
                </div>
            </div>
        `;
        
        // Update step info
        if (currentStep < solution.length) {
            const move = solution[currentStep];
            const numbers = move.cells.map(c => originalGrid[c.row][c.col]).join(' + ');
            stepInfo.innerHTML = `Step <strong>${currentStep + 1}</strong> of <strong>${solution.length}</strong><br>
                <div style="margin-top: 10px; font-size: 16px;">Remove: ${numbers} = 10</div>`;
        } else {
            stepInfo.innerHTML = `<div style="color: #2e7d32; font-size: 18px;">‚úÖ Puzzle solved! Cleared ${solution.length} groups.</div>`;
        }
        
        // Update buttons
        resetBtn.disabled = currentStep === 0;
        prevBtn.disabled = currentStep === 0;
        nextBtn.disabled = currentStep >= solution.length;
    }
    
    resetBtn.addEventListener('click', () => {
        currentStep = 0;
        renderGrid();
    });
    
    prevBtn.addEventListener('click', () => {
        if (currentStep > 0) {
            currentStep--;
            renderGrid();
        }
    });
    
    nextBtn.addEventListener('click', () => {
        if (currentStep < solution.length) {
            currentStep++;
            renderGrid();
        }
    });
    
    newPuzzleBtn.addEventListener('click', () => {
        originalGrid = null;
        solution = [];
        currentStep = 0;
        gridInput.value = '';
        gridDisplay.style.display = 'none';
        uploadSection.style.display = 'block';
    });
</script>
```

</body>
</html>
